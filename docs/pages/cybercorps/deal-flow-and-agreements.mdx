---
showOutline: false
content:
  width: 75%
---

# Deal Flow and Agreements

cyberCORPs introduce a concept often referred to as “deal-tech”: using smart contracts to automate legal agreements, especially for fundraising. The key contracts enabling this are the DealManager and the CyberAgreementRegistry, with support from MetaLeX’s escrow library LexScroWLite. Together, these handle the end-to-end lifecycle of an investment deal – from proposal, through signing, to funding and closing – entirely on-chain. When a founder or company wants to raise money (say via a SAFE or a token warrant deal), they begin by proposing a deal. This can be done through the web app UI or by calling the DealManager’s functions. The DealManager contract is deployed per cyberCORP and acts as an automated deal coordinator. It interfaces with the IssuanceManager to know what kinds of securities can be issued and uses the CyberAgreementRegistry to pull up the template of the legal agreement being executed. MetaLeX’s CyberAgreementRegistry is essentially a repository of standard deal templates and possibly a log of executed agreements. Each template (for example, “Y Combinator Post-Money SAFE v1.0” or a “SAFE + Token Warrant hybrid”) is identified by an ID (templateId). The registry stores the text of the agreement and the structured data fields it requires (such as valuation cap, investor name, etc.), so that the DealManager can reference it. This ensures that when deals are made on-chain, they are based on pre-vetted legal agreements whose terms are known and parameterized, rather than ad-hoc text.

Proposing and Signing a Deal: Using the DealManager, the founder (or their on-chain persona) initiates a deal by specifying the template ID, the terms (investment amount, cap, any discounts or interest if applicable), and the parties involved. The DealManager generates a unique agreement ID for this proposed deal. The founder then signs the deal proposal cryptographically (usually via an EIP-712 signature), which the smart contract can verify. This step is equivalent to the founder signing the term sheet or contract. Because the signature happens via the wallet, it’s recorded on-chain (or its hash is), and the CyberAgreementRegistry can log that one party has signed. At this point, the deal can be considered “proposed and partially signed” – awaiting the counterparty (the investor) to sign.

LexScroWLite – On-chain Escrow & Conditions: The moment a deal is proposed, the LexScroWLite subsystem comes into play to manage the conditional exchange of assets. The DealManager, under the hood, uses LexScroWLite to create an escrow tied to the agreement ID. This escrow will hold both sides of the deal until completion: on one side, the company’s asset – typically the digital stock certificates (NFTs) that will be issued to the investor – and on the other side, the investor’s payment (e.g. USDC or ETH). Initially, the company’s side of the escrow is prepared by reserving the stock tokens: the IssuanceManager mints the required SAFE token or stock certificate and holds it (or tags it as pending) for the investor. For example, if it’s a SAFE deal, a SAFE NFT representing the future equity claim is minted to the escrow (or to the company’s control with an endorsement to the investor). LexScroWLite will mark this certificate with an endorsement indicating it’s allocated to the specific investor pending payment GitHub GitHub. The investor’s side of the escrow remains empty until they sign. When the investor reviews the deal and is ready to commit, they countersign through the app (again via a cryptographic wallet signature) and simultaneously fund the deal. The DealManager (through LexScroWLite) will then pull in the investor’s funds to escrow – for instance, it will use safeTransferFrom to move USDC from the investor’s wallet into the escrow smart contract GitHub. At this point, LexScroWLite holds the money and the tokens in a pending state. Once the investor’s payment is received, the deal is considered fully signed and funded.


Finalizing the Deal: With both signatures in place and funds secured, the DealManager finalizes the agreement. LexScroWLite will release the assets: the payment is transferred to the company’s designated companyPayable address (essentially the corporate treasury wallet), and the NFT certificate is released to the investor’s wallet, officially making them a holder of that security. The DealManager marks the agreement as executed/closed, and events are emitted for record-keeping (e.g. a “DealFinalized” event with the agreement ID). The CyberAgreementRegistry can also store a hash or reference to the fully executed agreement (including any off-chain PDF or IPFS hash of the signed document, if applicable), giving a permanent record that the SAFE or investment contract was signed by both parties at a certain block/time. This automated flow covers not just simple SAFEs but can be extended to more complex deals. For example, MetaLeX has highlighted support for “token-enhanced hybrid deals” at [cybercorps.metalex.tech](https://cybercorps.metalex.tech) – a scenario common in Web3 startups where an investor’s deal might include a SAFE (equity) plus a token warrant or SAFT for future tokens. The cyberCORP protocol can accommodate this via extensions: the TokenWarrantExtension is one such module that can attach to a stock certificate NFT to also represent rights to a certain number of future tokens. During deal setup, if a hybrid deal template is chosen, the IssuanceManager will deploy a certificate with a warrant extension, and the DealManager will not only handle equity issuance but also trigger the token warrant logic (for instance, logging the investor’s entitlement to X tokens when the network’s token launches). All the pieces – SAFE, warrant, etc. – can be bundled under one agreement and managed through the same signing and escrow flow. The result is that even sophisticated financing arrangements can be executed in a few clicks on-chain, whereas traditionally they would require multiple documents and closing conditions.

Throughout the deal process, LexScroWLite enforces any additional conditions and safety checks. For instance, deals have an expiry time; if an investor fails to fund by the deadline, the DealManager can void the deal and release the company’s assets back to it (the NFT certificate would be voided or burned) GitHub. There’s also support for conditions like secrets or oracle checks – for example, a deal could be made conditional on an off-chain event or a passcode (a hash of which was provided at signing) being revealed. These are handled via plug-in ICondition contracts that LexScroWLite can consult before finalizing. If conditions aren’t met, the deal won’t finalize, giving a way to do things like KYC verification or regulatory compliance checks before money moves. By automating deal flow, cyberCORPs make fundraising faster and more secure. Agreements that used to be just PDFs exchanged over email are now live contracts performing their own escrow and fulfillment. Both founders and investors benefit: founders get quicker closes and assurance that funds will be released programmatically when terms are met, and investors get transparency and cryptographic security (their investment isn’t handed over until their equity tokens are ready). All of this happens without needing lawyers to intermediate the closing – the legal terms are pre-coded and the “settlement” is as simple as a blockchain transaction. As MetaLeX put it, “with cyberCORPs, fundraising just became on-chain, programmable, and a link away.”


